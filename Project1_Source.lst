                  2   $LIST
0000              4   
0000              5   org 0000H
0000 0204C6       6      ljmp main
0003              7      
0003              8   ; Timer/Counter 0 overflow interrupt vector
000B              9   org 0x000B
000B 0203E2      10            ljmp Timer0_ISR
000E             11   ; Timer/Counter 1 overflow interrupt vector
001B             12   org 0x001B
001B 0203E5      13            ljmp Timer1_ISR   
001E             14   ; Timer/Counter 2 overflow interrupt vector
002B             15   org 0x002B
002B 32          16       reti
002C             17   
002C             18   ; These register definitions needed by 'math32.inc'
0030             19   DSEG at 30H
0030             20   x:   ds 4
0034             21   y:   ds 4
0038             22   bcd: ds 5
003D             23   Count1ms: ds 2
003F             24   
003F             25   Seed: ds 4
0043             26   Score1: ds 1
0044             27   Score2: ds 1
0045             28   
0000             29   BSEG
0000             30   mf: dbit 1
0001             31   HLbit: dbit 1
0002             32   abortFlag: dbit 1
0003             33   
0003             34   PlayerWin: dbit 1 ; flag to tell who won: 0 - playerOne, 1 - playerTwo
0004             35   
                570   $LIST
                 37   $LIST
02C2             39   
02C2             40   cseg
02C2             41   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
02C2             42   
02C2             43   TIMER0_RATE1   EQU 4000     ; 2000Hz squarewave (peak amplitude of CEM-1203 speaker) ; Pin 1.1
02C2             44   TIMER0_RELOAD1 EQU ((65536-(CLK/TIMER0_RATE1))) ; LOW TONE
02C2             45   TIMER0_RATE2   EQU 4200     ; 2100Hz squarewave (peak amplitude of CEM-1203 speaker) ; Pin 1.1
02C2             46   TIMER0_RELOAD2 EQU ((65536-(CLK/TIMER0_RATE2))) ; HIGH TONE
02C2             47   TIMER1_RATE1   EQU 500     ; 250Hz squarewave (peak amplitude of CEM-1203 speaker) ; Pin 1.1
02C2             48   TIMER1_RELOAD1 EQU ((65536-(CLK/TIMER1_RATE1))) ; LOW TONE
02C2             49   
02C2             50   
02C2             51   ; These 'equ' must match the hardware wiring
02C2             52   LCD_RS equ P3.2
02C2             53   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
02C2             54   LCD_E  equ P3.3
02C2             55   LCD_D4 equ P3.4
02C2             56   LCD_D5 equ P3.5
02C2             57   LCD_D6 equ P3.6
02C2             58   LCD_D7 equ P3.7
02C2             59   
02C2             60   SOUND_OUT equ P1.1
02C2             61   BOOT_BUTTON equ P4.5
02C2             62   
                 64   	$LIST
036E             66   
036E             67   ;                     1234567890123456    <- This helps determine the location of the counter
036E 50657269    68   Initial_Message:  db 'Period (ns):   ', 0
     6F642028
     6E73293A
     20202000
037E 4E6F2073    69   No_Signal_Str:    db 'No signal      ', 0
     69676E61
     6C202020
     20202000
038E 4E6F2073    70   No_Signal_Str1:  db 'No signal T1', 0
     69676E61
     6C205431
     00
039B             71   
039B             72   ; Sends 10-digit BCD number in bcd to the LCD
039B             73   Display_10_digit_BCD:
039B C000        74            push ar0
039D A83C        74            mov r0, bcd+4
039F 120358      74            lcall ?Display_BCD
03A2 D000        74            pop ar0
03A4 C000        75            push ar0
03A6 A83B        75            mov r0, bcd+3
03A8 120358      75            lcall ?Display_BCD
03AB D000        75            pop ar0
03AD C000        76            push ar0
03AF A83A        76            mov r0, bcd+2
03B1 120358      76            lcall ?Display_BCD
03B4 D000        76            pop ar0
03B6 C000        77            push ar0
03B8 A839        77            mov r0, bcd+1
03BA 120358      77            lcall ?Display_BCD
03BD D000        77            pop ar0
03BF C000        78            push ar0
03C1 A838        78            mov r0, bcd+0
03C3 120358      78            lcall ?Display_BCD
03C6 D000        78            pop ar0
03C8 22          79            ret
03C9             80            
03C9             81   ;---------------------------------;
03C9             82   ; Routine to initialize the ISR   ;
03C9             83   ; for timer 0                     ;
03C9             84   ;---------------------------------;
03C9             85   Timer0_Init:
03C9 E589        86            mov a, TMOD
03CB 54F0        87            anl a, #0xf0 ; Clear the bits for timer 0
03CD 4401        88            orl a, #0x01 ; Configure timer 0 as 16-timer
03CF F589        89            mov TMOD, a
03D1 758CEA      90            mov TH0, #high(TIMER0_RELOAD1)
03D4 758A67      91            mov TL0, #low(TIMER0_RELOAD1)
03D7             92            ; Set autoreload value
03D7 75F4EA      93            mov RH0, #high(TIMER0_RELOAD1)
03DA 75F267      94            mov RL0, #low(TIMER0_RELOAD1)
03DD             95            ; Enable the timer and interrupts
03DD D2A9        96       setb ET0  ; Enable timer 0 interrupt
03DF C28C        97       clr TR0  ; DONT start timer 0 yet
03E1 22          98            ret
03E2             99   
03E2            100   ;---------------------------------;
03E2            101   ; ISR for timer 0.
03E2            102   ;---------------------------------;
03E2            103   Timer0_ISR:
03E2            104            ;clr TF0  ; According to the data sheet this is done for us already.
03E2 B291       105            cpl SOUND_OUT ; Connect speaker to P1.1!
03E4 32         106            reti
03E5            107   
03E5            108   Timer1_ISR: 
03E5            109            ;clr TF1 ; According to data sheet this is done for us already.
03E5 C0E0       110            push acc
03E7 C0D0       111            push psw
03E9            112            
03E9 053D       113            inc Count1ms+0
03EB E53D       114            mov a, Count1ms+0
03ED 7002       115            jnz Inc_Done
03EF 053E       116            inc Count1ms+1
03F1            117   
03F1            118   Inc_Done:
03F1 E53D       119       mov a, Count1ms+0
03F3 B4E80C     120       cjne a, #low(1000), Timer1_ISR_done
03F6 E53E       121       mov a, Count1ms+1
03F8 B40307     122       cjne a, #high(1000), Timer1_ISR_done
03FB            123   
03FB D202       124            setb abortFlag
03FD E4         125            clr a 
03FE            126            
03FE F53D       127            mov Count1ms+0, a
0400 F53E       128            mov Count1ms+1, a
0402            129            
0402            130   Timer1_ISR_done:
0402            131       ;Set_cursor(2,7)
0402            132       ;Display_char(#'g')
0402 D0D0       133       pop psw
0404 D0E0       134       pop acc
0406            135       
0406 32         136            reti
0407            137   
0407            138   InitTimer1:
0407 E589       139            mov a, TMOD
0409 540F       140            anl a, #0x0f ; Clear the bits for timer 1
040B 4410       141            orl a, #0x10 ; Configure timer 1 as 16-timer
040D F589       142            mov TMOD, a
040F 758D53     143            mov TH1, #high(TIMER1_RELOAD1)
0412 758B34     144            mov TL1, #low(TIMER1_RELOAD1)
0415 E4         145            clr a
0416 F53D       146            mov Count1ms+0, a
0418 F53E       147            mov Count1ms+1, a
041A            148            ; Set autoreload value
041A 75F553     149            mov RH1, #high(TIMER1_RELOAD1)
041D 75F334     150            mov RL1, #low(TIMER1_RELOAD1)
0420 D2AB       151            setb ET1 ; set timer1 interrupt to 1
0422 C28E       152            clr TR1 ; don't start timer right away
0424 22         153            ret
0425            154   
0425            155   ;Initializes timer/counter 2 as a 16-bit timer
0425            156   InitTimer2:
0425 75C800     157            mov T2CON, #0 ; Stop timer/counter.  Set as timer (clock input is pin 22.1184MHz).
0428            158            ; Set the reload value on overflow to zero (just in case is not zero)
0428 75CB00     159            mov RCAP2H, #0
042B 75CA00     160            mov RCAP2L, #0
042E D2AD       161            setb ET2
0430 22         162       ret
0431            163       
0431            164   Init_Seed:
0431            165            ; Wait for a push of the BOOT button
0431            166            ; to initialize random seed:
0431 D2CA       167            setb TR2
0433 20C5FD     168            jb BOOT_BUTTON, $
0436 C0E0       169            push acc
0438 7401       169            mov a, #1
043A 14         169            dec a
043B 120351     169            lcall ?Set_Cursor_2 ; Select column and row
043E D0E0       169            pop acc
0440 C0E0       170            push acc
0442 7421       170            mov a, #'!'
0444 120312     170            lcall ?WriteData
0447 D0E0       170            pop acc
0449 85CD3F     171            mov Seed+0, TH2
044C 754001     172            mov Seed+1, #0x01
044F 754187     173       mov Seed+2, #0x87
0452 85CC42     174       mov Seed+3, TL2
0455 C2CA       175       clr TR2
0457 22         176       ret
0458            177       
0458            178   Random:
0458            179            ; Seed = 214013*Seed + 2531011
0458 853F30     180            mov x+0, Seed+0
045B 854031     181            mov x+1, Seed+1
045E 854132     182            mov x+2, Seed+2
0461 854233     183            mov x+3, Seed+3
0464 7534FD     184            mov y+0, #low (214013 % 0x10000) 
0467 753543     184            mov y+1, #high(214013 % 0x10000) 
046A 753603     184            mov y+2, #low (214013 / 0x10000) 
046D 753700     184            mov y+3, #high(214013 / 0x10000) 
0470 1201A6     185            lcall mul32
0473 7534C3     186            mov y+0, #low (2531011 % 0x10000) 
0476 75359E     186            mov y+1, #high(2531011 % 0x10000) 
0479 753626     186            mov y+2, #low (2531011 / 0x10000) 
047C 753700     186            mov y+3, #high(2531011 / 0x10000) 
047F 1200F1     187            lcall add32
0482 85303F     188            mov Seed+0, x+0
0485 853140     189            mov Seed+1, x+1
0488 853241     190            mov Seed+2, x+2
048B 853342     191            mov Seed+3, x+3
048E 22         192            ret
048F            193   
048F            194   Wait_Random:
048F C002       195            push AR2
0491 AA3F       195            mov R2, Seed+0
0493 1202CD     195            lcall ?Wait_Milli_Seconds
0496 D002       195            pop AR2
0498 C002       196            push AR2
049A AA40       196            mov R2, Seed+1
049C 1202CD     196            lcall ?Wait_Milli_Seconds
049F D002       196            pop AR2
04A1 C002       197            push AR2
04A3 AA41       197            mov R2, Seed+2
04A5 1202CD     197            lcall ?Wait_Milli_Seconds
04A8 D002       197            pop AR2
04AA C002       198            push AR2
04AC AA42       198            mov R2, Seed+3
04AE 1202CD     198            lcall ?Wait_Milli_Seconds
04B1 D002       198            pop AR2
04B3 22         199            ret
04B4            200   
04B4            201   ;---------------------------------;
04B4            202   ; Hardware initialization         ;
04B4            203   ;---------------------------------;
04B4            204   Initialize_All:
04B4 120425     205       lcall InitTimer2
04B7 1203C9     206       lcall Timer0_Init
04BA 120407     207       lcall InitTImer1
04BD 12031C     208       lcall LCD_4BIT ; Initialize LCD
04C0 D2AF       209       setb EA
04C2 120431     210       lcall Init_Seed
04C5            211            
04C5 22         212            ret
04C6            213   
04C6            214   ;---------------------------------;
04C6            215   ; Main program loop               ;
04C6            216   ;---------------------------------;
04C6            217   main:
04C6            218       ; Initialize the hardware:
04C6 75817F     219       mov SP, #7FH
04C9 1204B4     220       lcall Initialize_All
04CC D280       221       setb P0.0 ; Pin is used as input for 555 timer for timer/counter2
04CE D281       222       setb P0.1 ; Pin for 555 timer for timer/counter1
04D0 C201       223       clr HLbit 
04D2 C28C       224       clr TR0 ; clear timer 0 so no sound when game first starts
04D4 C202       225       clr abortFlag
04D6 754300     226       mov Score1, #0
04D9 754400     227       mov Score2, #0
04DC            228       
04DC C2A0       229       clr P2.0
04DE            230   
04DE C0E0       231            push acc
04E0 7401       231            mov a, #1
04E2 14         231            dec a
04E3 120353     231            lcall ?Set_Cursor_1 ; Select column and row
04E6 D0E0       231            pop acc
04E8            232       ;Send_Constant_String(#Initial_Message) 
04E8            233       
04E8            234   ; LETS SAY HIGHER TONE IS BADDDDDD
04E8            235   forever:
04E8            236   
04E8            237            ; First part of the game: decide which freq to buzz at
04E8 120458     238            lcall Random
04EB E540       239            mov a, Seed+1
04ED A2E3       240            mov c, acc.3
04EF 9201       241            mov HLbit, c
04F1 4009       242            jc setup_tone2 ; if carry is one, we play tone2
04F3            243            ; if carry is zero, we play tone1, the LOW tone
04F3 75F4EA     244            mov RH0, #high(TIMER0_RELOAD1)
04F6 75F267     245            mov RL0, #low(TIMER0_RELOAD1)
04F9 020502     246            ljmp play
04FC            247            
04FC            248            setup_tone2: ; get ready to play tone2, the HIGH tone
04FC 75F4EB     249                    mov RH0, #high(TIMER0_RELOAD2)
04FF 75F26E     250                    mov RL0, #low(TIMER0_RELOAD2)
0502            251            
0502            252            
0502            253            play: ; activates tone
0502 D28E       254                    setb TR1 ; start timer1 
0504 D28C       255                    setb TR0
0506            256            
0506 12055A     257            lcall pin0period ; start check for capacitance (resulting in period) change
0509            258            
0509            259            ; When pin0_period returns, a player will have either won a point or lost a 
0509            260            ; point (unless already at zero). Now we need to update scoreboard and 
0509            261            ; if there is a winner, declare the winner
0509            262            
0509            263            ; to be done soon
0509 C002       264            push AR2
050B 7AFA       264            mov R2, #250
050D 1202CD     264            lcall ?Wait_Milli_Seconds
0510 D002       264            pop AR2
0512 C002       265            push AR2
0514 7AFA       265            mov R2, #250
0516 1202CD     265            lcall ?Wait_Milli_Seconds
0519 D002       265            pop AR2
051B C002       266            push AR2
051D 7AFA       266            mov R2, #250
051F 1202CD     266            lcall ?Wait_Milli_Seconds
0522 D002       266            pop AR2
0524 C002       267            push AR2
0526 7AFA       267            mov R2, #250
0528 1202CD     267            lcall ?Wait_Milli_Seconds
052B D002       267            pop AR2
052D            268            
052D            269            ; Wait a random time before playing the next sound
052D            270            ; Once a sound plays, it plays indefinitely till a slap occurs
052D            271            ; Once a slap occurs, calculate points, and wait to play the next sound
052D            272            ; To wait for a slap to occur, potentially use some sort of loop
052D            273            ;Wait_Milli_Seconds(#250)
052D            274            ;Wait_Milli_Seconds(#250)       
052D C28C       275            clr TR0
052F 12048F     276            lcall Wait_Random ; wait a random amount of time before playing the next tone
0532 0204E8     277            ljmp forever
0535            278            
0535            279   tooSlow:
0535 C28E       280            clr TR1
0537 C202       281            clr abortFlag
0539 C28C       282            clr TR0 ; stop the buzzer
053B C002       283            push AR2
053D 7AFA       283            mov R2, #250
053F 1202CD     283            lcall ?Wait_Milli_Seconds
0542 D002       283            pop AR2
0544 C002       284            push AR2
0546 7AFA       284            mov R2, #250
0548 1202CD     284            lcall ?Wait_Milli_Seconds
054B D002       284            pop AR2
054D C0E0       285            push acc
054F 740C       285            mov a, #12
0551 14         285            dec a
0552 120353     285            lcall ?Set_Cursor_1 ; Select column and row
0555 D0E0       285            pop acc
0557 0204E8     286            ljmp forever
055A            287   
055A            288   ; Determine period of 555 Timer for player 1
055A            289   pin0period: 
055A 2002D8     290            jb abortFlag, tooSlow
055D            291       ; synchronize with rising edge of the signal applied to pin P0.0
055D C2CA       292       clr TR2 ; Stop timer 2
055F 75CC00     293       mov TL2, #0
0562 75CD00     294       mov TH2, #0
0565 C2CF       295       clr TF2 ; clear timer2 overflow flag
0567 D2CA       296       setb TR2
0569            297   synch1:
0569 20CF41     298            jb TF2, no_signal0_helper_again ; If the timer overflows, we assume there is no signal
056C 2080FA     299       jb P0.0, synch1
056F            300   synch2:    
056F 20CF3B     301            jb TF2, no_signal0_helper_again
0572 3080FA     302       jnb P0.0, synch2
0575            303       
0575            304       ; Measure the period of the signal applied to pin P0.0
0575 C2CA       305       clr TR2
0577 75CC00     306       mov TL2, #0
057A 75CD00     307       mov TH2, #0
057D C2CF       308       clr TF2
057F D2CA       309       setb TR2 ; Start timer 2
0581            310   measure1:
0581 20CF79     311            jb TF2, no_signal_helper
0584 2080FA     312       jb P0.0, measure1
0587            313   measure2:    
0587 20CF73     314            jb TF2, no_signal_helper
058A 3080FA     315       jnb P0.0, measure2
058D C2CA       316       clr TR2 ; Stop timer 2, [TH2,TL2] * 45.21123ns is the period
058F 75349B     317            mov y+0, #low (45211 % 0x10000) 
0592 7535B0     317            mov y+1, #high(45211 % 0x10000) 
0595 753600     317            mov y+2, #low (45211 / 0x10000) 
0598 753700     317            mov y+3, #high(45211 / 0x10000) 
059B 85CC30     318       mov x+0, TL2
059E 85CD31     319       mov x+1, TH2
05A1 753200     320       mov x+2, #0
05A4 753300     321       mov x+3, #0
05A7 1201A6     322       lcall mul32
05AA 0205B0     323            ljmp next
05AD            324   no_signal0_helper_again:
05AD 0205FD     325            ljmp no_signal_helper
05B0            326       next:
05B0 7534E8     327            mov y+0, #low (1000 % 0x10000) 
05B3 753503     327            mov y+1, #high(1000 % 0x10000) 
05B6 753600     327            mov y+2, #low (1000 / 0x10000) 
05B9 753700     327            mov y+3, #high(1000 / 0x10000) 
05BC 120233     328       lcall div32
05BF C0E0       329            push acc
05C1 7404       329            mov a, #4
05C3 14         329            dec a
05C4 120353     329            lcall ?Set_Cursor_1 ; Select column and row
05C7 D0E0       329            pop acc
05C9 12002C     330       lcall hex2bcd
05CC 12039B     331       lcall Display_10_digit_BCD
05CF            332        ; x has the period at this point
05CF 7534B0     333            mov y+0, #low (398000 % 0x10000) 
05D2 753512     333            mov y+1, #high(398000 % 0x10000) 
05D5 753606     333            mov y+2, #low (398000 / 0x10000) 
05D8 753700     333            mov y+3, #high(398000 / 0x10000) 
05DB 120150     334       lcall x_gt_y
05DE 200062     335       jb mf, pin1period
05E1 753440     336            mov y+0, #low (392000 % 0x10000) 
05E4 7535FB     336            mov y+1, #high(392000 % 0x10000) 
05E7 753605     336            mov y+2, #low (392000 / 0x10000) 
05EA 753700     336            mov y+3, #high(392000 / 0x10000) 
05ED 120134     337       lcall x_lt_y
05F0 200030     338       jb mf, no_signal
05F3 C28C       339       clr TR0 ; when a hit is detected, stop the buzzer
05F5            340       ; Handle winning a point
05F5 200108     341       jb HLbit, dec_score1
05F8            342       ;mov a, Score1
05F8            343       ;add a, #1
05F8            344       ;da a
05F8            345       ;mov Score1, a
05F8 0543       346       inc Score1
05FA 020606     347       ljmp pin0_return
05FD            348       
05FD            349   no_signal_helper:
05FD 020623     350            ljmp no_signal
0600            351       
0600            352   dec_score1:
0600 E543       353            mov a, Score1
0602 6002       354            jz pin0_return
0604            355            ;add a, #99
0604            356            ;da a
0604            357            ;mov Score1, a
0604 1543       358            dec Score1
0606            359   
0606            360   pin0_return:
0606            361            ; Convert the result to BCD and display on LCD
0606 C0E0       362            push acc
0608 7401       362            mov a, #1
060A 14         362            dec a
060B 120353     362            lcall ?Set_Cursor_1 ; Select column and row
060E D0E0       362            pop acc
0610 854330     363            mov x, Score1
0613 120639     364            lcall zero_3x_bytes_0
0616 12002C     365            lcall hex2bcd
0619            366            ;lcall Display_10_digit_BCD
0619 C000       367            push ar0
061B A843       367            mov r0, Score1
061D 120358     367            lcall ?Display_BCD
0620 D000       367            pop ar0
0622 22         368       ret 
0623            369   
0623            370   no_signal:       
0623 C0E0       371            push acc
0625 740F       371            mov a, #15
0627 14         371            dec a
0628 120351     371            lcall ?Set_Cursor_2 ; Select column and row
062B D0E0       371            pop acc
062D C0E0       372            push acc
062F 7421       372            mov a, #'!'
0631 120312     372            lcall ?WriteData
0634 D0E0       372            pop acc
0636 020643     373       ljmp pin1period
0639            374   
0639            375   zero_3x_bytes_0:
0639 753100     376            mov x+1, #0
063C 753200     377            mov x+2, #0
063F 753300     378            mov x+3, #0
0642 22         379            ret
0643            380   
0643            381   ; Determine period for 555 timer for player 2
0643            382   pin1period:
0643 C002       383            push AR2
0645 7A64       383            mov R2, #100
0647 1202CD     383            lcall ?Wait_Milli_Seconds
064A D002       383            pop AR2
064C            384            
064C            385       ; synchronize with rising edge of the signal applied to pin P0.0
064C C2CA       386       clr TR2 ; Stop timer 2
064E 75CC00     387       mov TL2, #0
0651 75CD00     388       mov TH2, #0
0654 C2CF       389       clr TF2 ; clear timer1 overflow flag
0656 D2CA       390       setb TR2
0658            391   synch1_1:
0658 20CF18     392            jb TF2, no_signal_helper_again ; If the timer overflows, we assume there is no signal
065B 2081FA     393       jb P0.1, synch1_1
065E            394   synch2_1:    
065E 20CF12     395            jb TF2, no_signal_helper_again
0661 3081FA     396       jnb P0.1, synch2_1
0664            397       
0664            398       ; Measure the period of the signal applied to pin P0.0
0664 C2CA       399       clr TR2
0666 75CC00     400       mov TL2, #0
0669 75CD00     401       mov TH2, #0
066C C2CF       402       clr TF2
066E D2CA       403       setb TR2 ; Start timer 2
0670 020676     404            ljmp measure1_1
0673            405   no_signal_helper_again:
0673 0206EC     406            ljmp no_signal_1_helper
0676            407   measure1_1:
0676 20CF73     408            jb TF2, no_signal_1_helper
0679 2081FA     409       jb P0.1, measure1_1
067C            410   measure2_1:    
067C 20CF6D     411            jb TF2, no_signal_1_helper
067F 3081FA     412       jnb P0.1, measure2_1
0682 C2CA       413       clr TR2 ; Stop timer 2, [TH2,TL2] * 45.21123ns is the period
0684 75349B     414            mov y+0, #low (45211 % 0x10000) 
0687 7535B0     414            mov y+1, #high(45211 % 0x10000) 
068A 753600     414            mov y+2, #low (45211 / 0x10000) 
068D 753700     414            mov y+3, #high(45211 / 0x10000) 
0690 85CC30     415       mov x+0, TL2
0693 85CD31     416       mov x+1, TH2
0696 C0E0       417            push acc
0698 7404       417            mov a, #4
069A 14         417            dec a
069B 120351     417            lcall ?Set_Cursor_2 ; Select column and row
069E D0E0       417            pop acc
06A0 753200     418       mov x+2, #0
06A3 753300     419       mov x+3, #0
06A6 1201A6     420       lcall mul32
06A9 7534E8     421            mov y+0, #low (1000 % 0x10000) 
06AC 753503     421            mov y+1, #high(1000 % 0x10000) 
06AF 753600     421            mov y+2, #low (1000 / 0x10000) 
06B2 753700     421            mov y+3, #high(1000 / 0x10000) 
06B5 120233     422       lcall div32
06B8            423       ; x has the period at this point
06B8 7534C0     424            mov y+0, #low (440000 % 0x10000) 
06BB 7535B6     424            mov y+1, #high(440000 % 0x10000) 
06BE 753606     424            mov y+2, #low (440000 / 0x10000) 
06C1 753700     424            mov y+3, #high(440000 / 0x10000) 
06C4 120150     425       lcall x_gt_y
06C7 200048     426       jb mf, no_signal_1
06CA 12002C     427       lcall hex2bcd
06CD 12039B     428       lcall Display_10_digit_BCD
06D0 7534D8     429            mov y+0, #low (407000 % 0x10000) 
06D3 753535     429            mov y+1, #high(407000 % 0x10000) 
06D6 753606     429            mov y+2, #low (407000 / 0x10000) 
06D9 753700     429            mov y+3, #high(407000 / 0x10000) 
06DC 120134     430       lcall x_lt_y
06DF 200030     431       jb mf, no_signal_1
06E2            432       
06E2 C28C       433       clr TR0 ; when a hit is detected, stop the buzzer
06E4            434   ; Handle a press depending on tone
06E4 200108     435       jb HLbit, dec_score2
06E7            436       ;mov a, Score2
06E7            437       ;add a, #1
06E7            438       ;da a
06E7            439       ;mov Score1, a
06E7 0544       440       inc Score2
06E9 0206F5     441       ljmp pin1_return
06EC            442       
06EC            443   no_signal_1_helper:
06EC 020712     444            ljmp no_signal_1
06EF            445       
06EF            446   dec_score2:
06EF E544       447            mov a, Score2
06F1 6002       448            jz pin1_return ; if already zero, go to end
06F3            449            ;add a, #99
06F3            450            ;da a
06F3            451            ;mov Score2, a
06F3 1544       452            dec Score2
06F5            453   
06F5            454   pin1_return:
06F5            455            ; Convert the result to BCD and display on LCD
06F5 C0E0       456            push acc
06F7 7401       456            mov a, #1
06F9 14         456            dec a
06FA 120351     456            lcall ?Set_Cursor_2 ; Select column and row
06FD D0E0       456            pop acc
06FF 854430     457            mov x, Score2
0702 12071F     458            lcall zero_3x_bytes_1
0705 12002C     459            lcall hex2bcd
0708            460            ;lcall Display_10_digit_BCD
0708 C000       461            push ar0
070A A844       461            mov r0, Score2
070C 120358     461            lcall ?Display_BCD
070F D000       461            pop ar0
0711 22         462       ret 
0712            463       
0712            464   no_signal_1:     
0712 C0E0       465            push acc
0714 740F       465            mov a, #15
0716 14         465            dec a
0717 120351     465            lcall ?Set_Cursor_2 ; Select column and row
071A D0E0       465            pop acc
071C 02055A     466       ljmp pin0period ; Repeat! 
071F            467       
071F            468   zero_3x_bytes_1:
071F 753100     469            mov x+1, #0
0722 753200     470            mov x+2, #0
0725 753300     471            mov x+3, #0
0728 22         472            ret
0729            473   end
